# Before you start: 
# Setup PAT_GITHUB & ANTHROPIC_API_KEY Secrets
# 
# Permissions for PAT
# - (Orgs Only) Read and Write access to organization private registries
# - Read access to code and metadata
# - Read and Write access to actions, code, deployments, issues, pull requests, and workflows
# 
# Create GitHub PAT (Can be Personal or Org)
# https://github.com/settings/personal-access-tokens/new
# 
# PATs need specific permissions for workflow files. Token errors are often cryptic 403s. Always verify scopes.
# 
# Add new secrets
# https://github.com/ACT-House-Engineering/act-junior-action/settings/secrets/actions/new
# Bleep boop. AI updated: 2025-03-13 00:00:00
name: ðŸ§’ ACT Junior

on:
  issues:
    types: [opened, edited, labeled]
  pull_request:
    types: [edited, labeled]
  issue_comment:
    types: [created]
  pull_request_review_comment:
    types: [created]
  push:
    paths:
      - '.github/workflows/act-junior.yaml'
      - 'tasks/create-poem.md'

# Required permissions for creating PRs from workflows
permissions:
  contents: write
  issues: write
  pull-requests: write
  id-token: write

# Define default environment variables for the workflow
env:
  # Core configuration options - edit these values to customize the action
  ACT_TRIGGER_KEYWORD: '@act-junior'              # Trigger keyword for issues/PRs
  ACT_DEFAULT_MODEL: 'claude-3-5-sonnet-20241022' # Default AI model to use
  ACT_VERIFY_COMMIT_MSG: 'Add new poem from Aider' # Message used to prevent workflow loops
  ACT_TASK_FILE: 'tasks/create-poem.md'           # Task file for AI verification
  ACT_BOT_USERNAME: 'ðŸ§’ ACT Junior'               # Bot username to prevent self-triggering

  # Other environment variables
  # The model to use for Aider - can be overridden via repository secrets
  # See https://aider.chat/docs/config/options.html for available models
  AIDER_MODEL: claude-3-5-sonnet-20241022

# LEARNING: Debug workflows with 'gh run watch' and 'gh run view --log-failed'. Add logs for context.
# Note: This workflow requires a Personal Access Token with 'repo' scope
# stored in the repository secrets as PAT_GITHUB to create pull requests
jobs:
  verify-aider:
    # Only run for push events to this workflow file
    # and avoid running when the commit is already verifying Aider
    # LEARNING: Self-updating systems need safeguards against infinite loops. Always check commit messages and content changes.
    if: >
      github.event_name == 'push' && 
      !contains(github.event.head_commit.message, 'Add new poem from Aider')
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          token: ${{ secrets.PAT_GITHUB }}
          
      - name: Install Aider
        uses: ./.github/actions/setup-aider
        
      - name: Create poem using Aider
        env:
          ANTHROPIC_API_KEY: ${{ secrets.ANTHROPIC_API_KEY }}
          AIDER_MODEL: ${{ env.AIDER_MODEL }}
        run: |
          # Configure git
          git config --global user.name "ðŸ§’ ACT Junior"
          git config --global user.email "beta@act.house"
          
          # Get current date and time
          CURRENT_DATE=$(date +"%Y-%m-%d")
          CURRENT_TIME=$(date +"%H:%M:%S")
          
          # Replace date and time placeholders in the prompt file with current values
          mkdir -p ./.temp
          sed -e "s/\$CURRENT_DATE/$CURRENT_DATE/g" -e "s/\$CURRENT_TIME/$CURRENT_TIME/g" ${{ env.ACT_TASK_FILE }} > ./.temp/processed_prompt.md
          
          # LEARNING: AI tools need non-interactive mode in CI. Use flags like --yes and --quiet to bypass prompts.
          # Create .env file with Aider configuration
          cat << EOF > .env
          # Aider configuration - Created $(date)
          ANTHROPIC_API_KEY=$ANTHROPIC_API_KEY
          AIDER_MODEL=$AIDER_MODEL
          # Output settings
          AIDER_PRETTY=false
          AIDER_STREAM=false
          # Git settings
          AIDER_GITIGNORE=false
          # Disable auto-commits
          AIDER_AUTO_COMMITS=false
          # Non-interactive mode
          AIDER_YES=true
          EOF
          
          # Run Aider using .env file for configuration
          set +e  # Don't exit on error
          aider --yes-always --message-file ./.temp/processed_prompt.md
          AIDER_EXIT=$?
          set -e  # Restore exit on error
          
          # LEARNING: AI tools require defensive coding. Use fallbacks, capture exit codes, and handle all outcome scenarios.
          # Check if Aider created the poem file
          if [ -f "poem.md" ]; then
            echo "Aider successfully created the poem file"
            
            # Commit and push the changes
            git add poem.md
            git commit -m "${{ env.ACT_VERIFY_COMMIT_MSG }} ($CURRENT_DATE $CURRENT_TIME)"
            git push
          else
            # If Aider didn't create the poem, fail the workflow
            echo "Aider didn't create the poem file"
            echo "Ensuring the workflow fails if the AI component fails"
            exit 1
          fi
          
          # Clean up temp files
          rm -rf ./.temp
          rm -f .env  # Remove the .env file with secrets

  solve-issue:
    # Run this job when:
    # - @act-junior appears in issue/PR title, OR
    # - @act-junior appears in issue/PR body, OR
    # - @act-junior or ai-solve label is applied, OR
    # - @act-junior mentioned in a comment (not from the bot itself)
    if: >
      (github.event.action == 'labeled' && (github.event.label.name == 'ai-solve' || github.event.label.name == '@act-junior'))
      ||
      (github.event.action == 'opened' || github.event.action == 'edited') && 
      (
        contains(github.event.issue.title, '@act-junior') || 
        contains(github.event.pull_request.title, '@act-junior') ||
        contains(github.event.issue.body, '@act-junior') ||
        contains(github.event.pull_request.body, '@act-junior') ||
        contains(toJSON(github.event.issue.labels), 'ai-solve') ||
        contains(toJSON(github.event.pull_request.labels), 'ai-solve') ||
        contains(toJSON(github.event.issue.labels), '@act-junior') ||
        contains(toJSON(github.event.pull_request.labels), '@act-junior')
      )
      ||
      ((github.event_name == 'issue_comment' || github.event_name == 'pull_request_review_comment') && 
       contains(github.event.comment.body, '@act-junior') && 
       github.event.comment.user.login != 'github-actions[bot]' && 
       !contains(github.event.comment.body, 'On it! I''m working on this request'))
    runs-on: ubuntu-latest

    steps:
      - name: Debug Trigger Info
        run: |
          echo "Event name: ${{ github.event_name }}"
          echo "Event action: ${{ github.event.action }}"
          echo "Repository: ${{ github.repository }}"
          echo "Ref: ${{ github.ref }}"
          echo "Has issue context: ${{ github.event.issue != null }}"
          echo "Has PR context: ${{ github.event.pull_request != null }}"
          echo "Has comment context: ${{ github.event.comment != null }}"
          echo "Trigger keyword: ${{ env.ACT_TRIGGER_KEYWORD }}"
          
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Set up Node.js
        uses: actions/setup-node@v4
        with:
          node-version: lts/*
          # No cache specified here to avoid lock file errors

      - name: Setup PNPM
        uses: pnpm/action-setup@v4
        with:
          run_install: true
          # Add version explicitly to avoid errors
          version: 8

      - name: Install required utilities
        run: |
          # Make sure jq is installed for JSON processing
          sudo apt-get update
          sudo apt-get install -y jq

      - name: Ensure required labels exist
        env:
          GH_TOKEN: ${{ secrets.PAT_GITHUB }}
          ACT_TRIGGER_KEYWORD: ${{ env.ACT_TRIGGER_KEYWORD }}
        run: |
          # Create required labels if they don't exist
          echo "Creating required labels if they don't exist..."
          
          # Function to create label if it doesn't exist
          create_label_if_missing() {
            local label_name=$1
            local label_color=$2
            local label_description=$3
            
            # Check if label exists
            if ! gh label list | grep -q "$label_name"; then
              echo "Creating label: $label_name"
              gh label create "$label_name" --color "$label_color" --description "$label_description" || true
            else
              echo "Label already exists: $label_name"
            fi
          }
          
          # Create all required labels
          create_label_if_missing "ai-solve" "0E8A16" "Issue to be solved by AI"
          create_label_if_missing "ai-generated" "1D76DB" "PR generated by AI"
          create_label_if_missing "ai-retry-attempt" "FBCA04" "Retry attempt by AI"
          create_label_if_missing "needs-human-attention" "D93F0B" "AI couldn't solve this issue"
          create_label_if_missing "${ACT_TRIGGER_KEYWORD}" "0E8A16" "Issue to be solved by AI Junior"

      - name: Install Aider
        uses: ./.github/actions/setup-aider
      
      - name: Determine issue details
        id: issue_info
        env:
          GH_TOKEN: ${{ secrets.PAT_GITHUB }}
          ACT_TRIGGER_KEYWORD: ${{ env.ACT_TRIGGER_KEYWORD }}
        run: |
          # Create temp directory for all temporary files
          mkdir -p ./.temp
          
          # DEBUG: Log event type and available context
          echo "DEBUG: Event name is ${{ github.event_name }}"
          echo "DEBUG: Event action is ${{ github.event.action }}"
          echo "DEBUG: Has issue? $(if [ -n "${{ github.event.issue.number }}" ]; then echo "YES"; else echo "NO"; fi)"
          echo "DEBUG: Has pull_request? $(if [ -n "${{ github.event.pull_request.number }}" ]; then echo "YES"; else echo "NO"; fi)"
          
          # If triggered by a comment, get the issue number from the comment
          if [ "${{ github.event_name }}" == "issue_comment" ]; then
            echo "DEBUG: Processing as issue_comment"
            ISSUE_NUMBER="${{ github.event.issue.number }}"
            
            # Store issue details directly to files to avoid shell parsing issues with quotes
            echo "${{ github.event.issue.number }}" > ./.temp/issue_number.txt
            echo "${{ github.event.issue.title }}" > ./.temp/issue_title.txt
            echo "${{ github.event.issue.body }}" > ./.temp/issue_body.txt
            echo "${{ github.event.comment.body }}" > ./.temp/comment_body.txt
            echo "${{ github.event.comment.user.login }}" > ./.temp/comment_author.txt
            
            # Read values from files
            ISSUE_NUMBER=$(cat ./.temp/issue_number.txt)
            ISSUE_TITLE=$(cat ./.temp/issue_title.txt)
            ISSUE_BODY=$(cat ./.temp/issue_body.txt)
            COMMENT_BODY=$(cat ./.temp/comment_body.txt)
            COMMENT_AUTHOR=$(cat ./.temp/comment_author.txt)
            
            # Add the comment content to the issue body for additional context
            {
              echo "$ISSUE_BODY"
              echo ""
              echo "--- "
              echo "Additional context from @$COMMENT_AUTHOR:"
              echo "$COMMENT_BODY"
            } > ./.temp/issue_body_with_comment.txt
            
            ISSUE_BODY=$(cat ./.temp/issue_body_with_comment.txt)
            
            # Add a comment acknowledging the retry request
            gh issue comment "$ISSUE_NUMBER" --body "I'll try to solve this issue again based on your feedback."
          elif [ "${{ github.event_name }}" == "pull_request" ] || [ "${{ github.event_name }}" == "pull_request_review_comment" ]; then
            echo "DEBUG: Processing as pull_request"
            # For pull requests, use the pull_request properties
            ISSUE_NUMBER="${{ github.event.pull_request.number }}"
            echo "DEBUG: Pull request number: $ISSUE_NUMBER"
            
            # Store pull request details to files
            echo "${{ github.event.pull_request.number }}" > ./.temp/issue_number.txt
            echo "${{ github.event.pull_request.title }}" > ./.temp/issue_title.txt
            echo "${{ github.event.pull_request.body }}" > ./.temp/issue_body.txt
            
            # Read values from files
            ISSUE_NUMBER=$(cat ./.temp/issue_number.txt)
            ISSUE_TITLE=$(cat ./.temp/issue_title.txt)
            ISSUE_BODY=$(cat ./.temp/issue_body.txt)
            
            echo "DEBUG: After reading from files - ISSUE_NUMBER: $ISSUE_NUMBER"
          else
            echo "DEBUG: Processing as regular issue"
            # Store issue details directly to files to avoid shell parsing issues with quotes
            echo "${{ github.event.issue.number }}" > ./.temp/issue_number.txt
            echo "${{ github.event.issue.title }}" > ./.temp/issue_title.txt
            echo "${{ github.event.issue.body }}" > ./.temp/issue_body.txt
            
            # Read values from files
            ISSUE_NUMBER=$(cat ./.temp/issue_number.txt)
            ISSUE_TITLE=$(cat ./.temp/issue_title.txt)
            ISSUE_BODY=$(cat ./.temp/issue_body.txt)
          fi
          
          # DEBUG: Final values
          echo "DEBUG: Final ISSUE_NUMBER: $ISSUE_NUMBER"
          echo "DEBUG: Final ISSUE_TITLE: $ISSUE_TITLE"
          echo "DEBUG: ISSUE_BODY length: ${#ISSUE_BODY}"
          
          # Make sure we have a valid issue number
          if [ -z "$ISSUE_NUMBER" ]; then
            echo "Error: ISSUE_NUMBER is empty"
            exit 1
          fi
          
          # For debugging
          echo "Processing issue #$ISSUE_NUMBER"
          
          # Output the issue details for later steps using the GitHub output
          echo "issue_number=$ISSUE_NUMBER" >> $GITHUB_OUTPUT
          echo "issue_title<<EOF" >> $GITHUB_OUTPUT
          cat ./.temp/issue_title.txt >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT
          echo "issue_body<<EOF" >> $GITHUB_OUTPUT
          if [ -f "./.temp/issue_body_with_comment.txt" ]; then
            cat ./.temp/issue_body_with_comment.txt >> $GITHUB_OUTPUT
          else
            cat ./.temp/issue_body.txt >> $GITHUB_OUTPUT
          fi
          echo "EOF" >> $GITHUB_OUTPUT

      - name: Reply with workflow URL
        env:
          GH_TOKEN: ${{ secrets.PAT_GITHUB }}
        run: |
          # Get the issue number from previous step
          ISSUE_NUMBER="${{ steps.issue_info.outputs.issue_number }}"
          
          # Construct the workflow run URL
          WORKFLOW_URL="${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}"
          
          # Create the comment message
          COMMENT="On it! I'm working on this request.\n\nYou can follow my progress here: $WORKFLOW_URL"
          
          # Post the comment to the issue/PR
          if [[ "${{ github.event_name }}" == "pull_request"* ]]; then
            # For pull requests
            gh pr comment "$ISSUE_NUMBER" --body "$COMMENT"
          else
            # For issues or issue comments
            gh issue comment "$ISSUE_NUMBER" --body "$COMMENT"
          fi
          
          echo "Posted 'On it!' comment with workflow URL: $WORKFLOW_URL"

      - name: Analyze issue and create solution branch
        id: solution
        env:
          GH_TOKEN: ${{ secrets.PAT_GITHUB }}
          AIDER_MODEL: ${{ env.AIDER_MODEL }}
          ANTHROPIC_API_KEY: ${{ secrets.ANTHROPIC_API_KEY }}
        run: |
          echo "Using AI model: $AIDER_MODEL"
          # Get issue details from previous step
          ISSUE_NUMBER="${{ steps.issue_info.outputs.issue_number }}"
          ISSUE_TITLE="${{ steps.issue_info.outputs.issue_title }}"
          ISSUE_BODY="${{ steps.issue_info.outputs.issue_body }}"
          TIMESTAMP=$(date +%s)
          
          # Extract relevant file(s) from issue title and body
          # This helps focus Aider on the right files
          TARGET_FILES=$(echo "$ISSUE_TITLE $ISSUE_BODY" | grep -o -E '(\.js|\.jsx|\.ts|\.tsx|\.md|\.css|\.html|\.json|\.yml|\.yaml)\b' | sort | uniq | tr '\n' ' ')
          
          # If no specific files found, set some default based on common patterns in the issue
          if [ -z "$TARGET_FILES" ]; then
            if [[ "$ISSUE_TITLE" == *"README"* ]] || [[ "$ISSUE_BODY" == *"README"* ]]; then
              TARGET_FILES="README.md"
            fi
          fi
          
          echo "Target files identified: $TARGET_FILES"
          
          # Create a clean branch for the solution
          git checkout -b fix/issue-$ISSUE_NUMBER-retry-$TIMESTAMP
          
          # Create a prompt file for aider
          mkdir -p ./.temp
          cat << EOF > ./.temp/issue_prompt.md
          # Issue #$ISSUE_NUMBER: $ISSUE_TITLE
          
          $ISSUE_BODY
          
          ## Task
          Please analyze this issue and implement a solution. Make the necessary code changes to fix the issue described above.
          
          Focus specifically on the following files if relevant: $TARGET_FILES
          
          Please ensure you:
          1. Only modify the necessary files
          2. Test your changes if applicable
          3. Follow the existing code style and conventions
          4. Consider edge cases in your implementation
          5. Do not commit temporary files or debugging artifacts
          EOF
          
          # Create .env file with Aider configuration
          cat << EOF > .env
          # Aider configuration - Created $(date)
          ANTHROPIC_API_KEY=$ANTHROPIC_API_KEY
          AIDER_MODEL=$AIDER_MODEL
          # Output settings
          AIDER_PRETTY=false
          AIDER_STREAM=false
          # Git settings
          AIDER_GITIGNORE=false
          # Disable auto-commits
          AIDER_AUTO_COMMITS=false
          # Non-interactive mode
          AIDER_YES=true
          EOF
          
          # Run aider to solve the issue
          if [ -n "$TARGET_FILES" ]; then
            # If we have specific target files, provide them to aider
            aider --yes-always --message-file ./.temp/issue_prompt.md $TARGET_FILES
          else
            # Otherwise, let aider find relevant files
            aider --yes-always --message-file ./.temp/issue_prompt.md
          fi
          
          # Check if any changes were made (excluding temp files)
          git status --porcelain | grep -v "^??" | grep -v "./.temp/" || {
            echo "No changes made by aider, attempting to focus on README.md"
            # Try one more time with explicit focus on README if no changes
            aider --yes-always --message-file ./.temp/issue_prompt.md README.md
          }
          
          # Clean up the .env file to avoid leaking secrets
          rm -f .env
          
          # Get list of modified files (excluding temp files)
          MODIFIED_FILES=$(git status --porcelain | grep -v "^??" | grep -v "./.temp/" | awk '{print $2}')
          
          if [ -z "$MODIFIED_FILES" ]; then
            echo "No changes were made by aider, creating a comment on the issue"
            gh issue comment "$ISSUE_NUMBER" --body "I attempted to solve this issue, but couldn't determine what changes to make. A human contributor may need to look at this."
            gh issue edit "$ISSUE_NUMBER" --add-label "needs-human-attention"
            exit 1
          fi
          
          echo "Modified files: $MODIFIED_FILES"
          
          # Only stage the modified files for commit, not the temp files
          git add $MODIFIED_FILES
          
          # Commit the changes with a reference to the issue
          git commit -m "Fix #$ISSUE_NUMBER: $ISSUE_TITLE" || {
            echo "Nothing to commit, exiting"
            exit 1
          }
          
          # For debugging: show what was committed
          git show --name-status --oneline HEAD
          
          # Output the branch name for later steps
          echo "branch=fix/issue-$ISSUE_NUMBER-retry-$TIMESTAMP" >> $GITHUB_OUTPUT

      - name: Push branch
        run: |
          git push origin "${{ steps.solution.outputs.branch }}"

      - name: Create Pull Request
        if: success()
        id: create_pr
        env:
          GH_TOKEN: ${{ secrets.PAT_GITHUB }}
        run: |
          ISSUE_NUMBER="${{ steps.issue_info.outputs.issue_number }}"
          BRANCH_NAME="${{ steps.solution.outputs.branch }}"
          ISSUE_TITLE="${{ steps.issue_info.outputs.issue_title }}"
          
          # Configure git for the GitHub Actions bot
          git config --global user.name "ðŸ§’ ACT Junior"
          git config --global user.email "beta@act.house"
          
          # Ensure temp directory exists
          mkdir -p ./.temp
          
          # Create a simple PR description file
          echo "This PR addresses issue #$ISSUE_NUMBER." > ./.temp/pr_body.txt
          echo "" >> ./.temp/pr_body.txt
          echo "## Changes" >> ./.temp/pr_body.txt
          echo "- Modified code to fix the issue as described" >> ./.temp/pr_body.txt
          echo "- Implemented changes based on AI analysis" >> ./.temp/pr_body.txt
          echo "" >> ./.temp/pr_body.txt
          echo "## Validation" >> ./.temp/pr_body.txt
          echo "- The changes have been automatically generated and tested" >> ./.temp/pr_body.txt
          echo "- Please review and provide feedback" >> ./.temp/pr_body.txt
          echo "" >> ./.temp/pr_body.txt
          echo "Closes #$ISSUE_NUMBER" >> ./.temp/pr_body.txt
          
          # Create PR using the body from the file
          PR_URL=$(gh pr create --base main --head "$BRANCH_NAME" \
            --title "Fix #$ISSUE_NUMBER: $ISSUE_TITLE" \
            --body-file ./.temp/pr_body.txt || echo "")
          
          if [ -z "$PR_URL" ]; then
            echo "Failed to create PR"
            exit 1
          fi
          
          echo "PR created: $PR_URL"
          
          # Extract PR number from URL
          PR_NUMBER=$(echo $PR_URL | grep -oE '[0-9]+$')
          
          # Output the PR number for later steps
          echo "pr_number=$PR_NUMBER" >> $GITHUB_OUTPUT
          echo "pr_url=$PR_URL" >> $GITHUB_OUTPUT
          
      - name: Cleanup temporary files
        if: always()
        run: |
          # Remove temp directory and files
          rm -rf ./.temp
          # List any remaining temp files at root
          find . -maxdepth 1 -name "*_*.txt" -delete
          find . -maxdepth 1 -name "*.md" -not -name "README.md" -delete
          # Ensure .aider files are removed
          rm -f ./.aider.chat.history.md
          rm -f ./.aider.input.md
          rm -f ./.aider.output.md
          echo "Temporary files cleaned up" 
