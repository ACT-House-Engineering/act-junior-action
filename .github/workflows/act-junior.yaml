# Before you start: 
# Setup PAT_GITHUB & ANTHROPIC_API_KEY Secrets
# 
# Permissions for PAT
# - Read and Write access to organization private registries
# - Read access to code and metadata
# - Read and Write access to actions, deployments, issues, and pull requests
# 
# Create GitHub PAT (Can be Personal or Org)
# https://github.com/settings/personal-access-tokens/new
# 
# Add new secrets
# https://github.com/ACT-House-Engineering/act-junior-action/settings/secrets/actions/new
# Bleep boop. AI updated: 2025-03-13
name: ðŸ§’ ACT Junior

on:
  issues:
    types: [opened, edited, labeled]
  pull_request:
    types: [opened, edited, labeled]
  issue_comment:
    types: [created]
  pull_request_review_comment:
    types: [created]
  push:
    paths:
      - '.github/workflows/act-junior.yaml'

# Required permissions for creating PRs from workflows
permissions:
  contents: write
  issues: write
  pull-requests: write
  id-token: write

# Define default environment variables for the workflow
env:
  # The model to use for Aider - can be overridden via repository secrets
  # See https://aider.chat/docs/config/options.html for available models
  # Recommended options: 
  # - claude-3-5-sonnet-20241022 (Anthropic)
  AIDER_MODEL: claude-3-5-sonnet-20241022

# Note: This workflow requires a Personal Access Token with 'repo' scope
# stored in the repository secrets as PAT_GITHUB to create pull requests
jobs:
  update-timestamp:
    # Only run for push events to this workflow file
    # and avoid running when the commit is already updating the timestamp
    if: github.event_name == 'push' && !contains(github.event.head_commit.message, 'Update AI timestamp')
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          token: ${{ secrets.PAT_GITHUB }}
          
      - name: Update timestamp in workflow file
        run: |
          # Configure git
          git config --global user.name "GitHub Actions Bot"
          git config --global user.email "actions@github.com"
          
          # Get current date
          CURRENT_DATE=$(date +"%Y-%m-%d")
          
          # Update the timestamp comment in the workflow file
          sed -i "s/# Bleep boop. AI updated: 2025-03-13
          
          # Check if there are changes
          if [[ -n $(git status --porcelain) ]]; then
            # Commit and push the changes
            git add .github/workflows/act-junior.yaml
            git commit -m "Update AI timestamp to $CURRENT_DATE"
            git push
          else
            echo "No changes to commit"
          fi

  solve-issue:
    # Run this job when:
    # - @act-junior appears in issue/PR title, OR
    # - @act-junior appears in issue/PR body, OR
    # - @act-junior or ai-solve label is applied, OR
    # - @act-junior mentioned in a comment
    if: >
      (github.event.action == 'labeled' && (github.event.label.name == 'ai-solve' || github.event.label.name == '@act-junior'))
      ||
      (github.event.action == 'opened' || github.event.action == 'edited') && 
      (
        contains(github.event.issue.title, '@act-junior') || 
        contains(github.event.pull_request.title, '@act-junior') ||
        contains(github.event.issue.body, '@act-junior') ||
        contains(github.event.pull_request.body, '@act-junior') ||
        contains(toJSON(github.event.issue.labels), 'ai-solve') ||
        contains(toJSON(github.event.pull_request.labels), 'ai-solve') ||
        contains(toJSON(github.event.issue.labels), '@act-junior') ||
        contains(toJSON(github.event.pull_request.labels), '@act-junior')
      )
      ||
      ((github.event_name == 'issue_comment' || github.event_name == 'pull_request_review_comment') && contains(github.event.comment.body, '@act-junior'))
    runs-on: ubuntu-latest

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Set up Node.js
        uses: actions/setup-node@v4
        with:
          node-version: lts/*
          # No cache specified here to avoid lock file errors

      - name: Setup PNPM
        uses: pnpm/action-setup@v4
        with:
          run_install: true
          # Add version explicitly to avoid errors
          version: 8

      - name: Install required utilities
        run: |
          # Make sure jq is installed for JSON processing
          sudo apt-get update
          sudo apt-get install -y jq

      - name: Ensure required labels exist
        env:
          GH_TOKEN: ${{ secrets.PAT_GITHUB }}
        run: |
          # Create required labels if they don't exist
          echo "Creating required labels if they don't exist..."
          
          # Function to create label if it doesn't exist
          create_label_if_missing() {
            local label_name=$1
            local label_color=$2
            local label_description=$3
            
            # Check if label exists
            if ! gh label list | grep -q "$label_name"; then
              echo "Creating label: $label_name"
              gh label create "$label_name" --color "$label_color" --description "$label_description" || true
            else
              echo "Label already exists: $label_name"
            fi
          }
          
          # Create all required labels
          create_label_if_missing "ai-solve" "0E8A16" "Issue to be solved by AI"
          create_label_if_missing "ai-generated" "1D76DB" "PR generated by AI"
          create_label_if_missing "ai-retry-attempt" "FBCA04" "Retry attempt by AI"
          create_label_if_missing "needs-human-attention" "D93F0B" "AI couldn't solve this issue"

      - name: Install Aider
        run: |
          pip install aider-chat
      
      - name: Determine issue details
        id: issue_info
        env:
          GH_TOKEN: ${{ secrets.PAT_GITHUB }}
        run: |
          # Create temp directory for all temporary files
          mkdir -p ./.temp
          
          # If triggered by a comment, get the issue number from the comment
          if [ "${{ github.event_name }}" == "issue_comment" ]; then
            ISSUE_NUMBER="${{ github.event.issue.number }}"
            
            # Store issue details directly to files to avoid shell parsing issues with quotes
            echo "${{ github.event.issue.number }}" > ./.temp/issue_number.txt
            echo "${{ github.event.issue.title }}" > ./.temp/issue_title.txt
            echo "${{ github.event.issue.body }}" > ./.temp/issue_body.txt
            echo "${{ github.event.comment.body }}" > ./.temp/comment_body.txt
            echo "${{ github.event.comment.user.login }}" > ./.temp/comment_author.txt
            
            # Read values from files
            ISSUE_NUMBER=$(cat ./.temp/issue_number.txt)
            ISSUE_TITLE=$(cat ./.temp/issue_title.txt)
            ISSUE_BODY=$(cat ./.temp/issue_body.txt)
            COMMENT_BODY=$(cat ./.temp/comment_body.txt)
            COMMENT_AUTHOR=$(cat ./.temp/comment_author.txt)
            
            # Add the comment content to the issue body for additional context
            {
              echo "$ISSUE_BODY"
              echo ""
              echo "--- "
              echo "Additional context from @$COMMENT_AUTHOR:"
              echo "$COMMENT_BODY"
            } > ./.temp/issue_body_with_comment.txt
            
            ISSUE_BODY=$(cat ./.temp/issue_body_with_comment.txt)
            
            # Add a comment acknowledging the retry request
            gh issue comment "$ISSUE_NUMBER" --body "I'll try to solve this issue again based on your feedback."
          else
            # Store issue details directly to files to avoid shell parsing issues with quotes
            echo "${{ github.event.issue.number }}" > ./.temp/issue_number.txt
            echo "${{ github.event.issue.title }}" > ./.temp/issue_title.txt
            echo "${{ github.event.issue.body }}" > ./.temp/issue_body.txt
            
            # Read values from files
            ISSUE_NUMBER=$(cat ./.temp/issue_number.txt)
            ISSUE_TITLE=$(cat ./.temp/issue_title.txt)
            ISSUE_BODY=$(cat ./.temp/issue_body.txt)
          fi
          
          # Make sure we have a valid issue number
          if [ -z "$ISSUE_NUMBER" ]; then
            echo "Error: ISSUE_NUMBER is empty"
            exit 1
          fi
          
          # For debugging
          echo "Processing issue #$ISSUE_NUMBER"
          
          # Output the issue details for later steps using the GitHub output
          echo "issue_number=$ISSUE_NUMBER" >> $GITHUB_OUTPUT
          echo "issue_title<<EOF" >> $GITHUB_OUTPUT
          cat ./.temp/issue_title.txt >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT
          echo "issue_body<<EOF" >> $GITHUB_OUTPUT
          if [ -f "./.temp/issue_body_with_comment.txt" ]; then
            cat ./.temp/issue_body_with_comment.txt >> $GITHUB_OUTPUT
          else
            cat ./.temp/issue_body.txt >> $GITHUB_OUTPUT
          fi
          echo "EOF" >> $GITHUB_OUTPUT

      - name: Analyze issue and create solution branch
        id: solution
        env:
          GH_TOKEN: ${{ secrets.PAT_GITHUB }}
          AIDER_MODEL: ${{ env.AIDER_MODEL }}
          ANTHROPIC_API_KEY: ${{ secrets.ANTHROPIC_API_KEY }}
        run: |
          echo "Using AI model: $AIDER_MODEL"
          # Get issue details from previous step
          ISSUE_NUMBER="${{ steps.issue_info.outputs.issue_number }}"
          ISSUE_TITLE="${{ steps.issue_info.outputs.issue_title }}"
          ISSUE_BODY="${{ steps.issue_info.outputs.issue_body }}"
          TIMESTAMP=$(date +%s)
          
          # Extract relevant file(s) from issue title and body
          # This helps focus Aider on the right files
          TARGET_FILES=$(echo "$ISSUE_TITLE $ISSUE_BODY" | grep -o -E '(\.js|\.jsx|\.ts|\.tsx|\.md|\.css|\.html|\.json|\.yml|\.yaml)\b' | sort | uniq | tr '\n' ' ')
          
          # If no specific files found, set some default based on common patterns in the issue
          if [ -z "$TARGET_FILES" ]; then
            if [[ "$ISSUE_TITLE" == *"README"* ]] || [[ "$ISSUE_BODY" == *"README"* ]]; then
              TARGET_FILES="README.md"
            fi
          fi
          
          echo "Target files identified: $TARGET_FILES"
          
          # Create a clean branch for the solution
          git checkout -b fix/issue-$ISSUE_NUMBER-retry-$TIMESTAMP
          
          # Create a prompt file for aider
          mkdir -p ./.temp
          cat << EOF > ./.temp/issue_prompt.md
          # Issue #$ISSUE_NUMBER: $ISSUE_TITLE
          
          $ISSUE_BODY
          
          ## Task
          Please analyze this issue and implement a solution. Make the necessary code changes to fix the issue described above.
          
          Focus specifically on the following files if relevant: $TARGET_FILES
          
          Please ensure you:
          1. Only modify the necessary files
          2. Test your changes if applicable
          3. Follow the existing code style and conventions
          4. Consider edge cases in your implementation
          5. Do not commit temporary files or debugging artifacts
          EOF
          
          # Run aider to solve the issue
          if [ -n "$TARGET_FILES" ]; then
            # If we have specific target files, provide them to aider
            aider --anthropic-api-key "$ANTHROPIC_API_KEY" --model "$AIDER_MODEL" --message-file ./.temp/issue_prompt.md $TARGET_FILES
          else
            # Otherwise, let aider find relevant files
            aider --anthropic-api-key "$ANTHROPIC_API_KEY" --model "$AIDER_MODEL" --message-file ./.temp/issue_prompt.md
          fi
          
          # Check if any changes were made (excluding temp files)
          git status --porcelain | grep -v "^??" | grep -v "./.temp/" || {
            echo "No changes made by aider, attempting to focus on README.md"
            # Try one more time with explicit focus on README if no changes
            aider --anthropic-api-key "$ANTHROPIC_API_KEY" --model "$AIDER_MODEL" --message-file ./.temp/issue_prompt.md README.md
          }
          
          # Get list of modified files (excluding temp files)
          MODIFIED_FILES=$(git status --porcelain | grep -v "^??" | grep -v "./.temp/" | awk '{print $2}')
          
          if [ -z "$MODIFIED_FILES" ]; then
            echo "No changes were made by aider, creating a comment on the issue"
            gh issue comment "$ISSUE_NUMBER" --body "I attempted to solve this issue, but couldn't determine what changes to make. A human contributor may need to look at this."
            gh issue edit "$ISSUE_NUMBER" --add-label "needs-human-attention"
            exit 1
          fi
          
          echo "Modified files: $MODIFIED_FILES"
          
          # Only stage the modified files for commit, not the temp files
          git add $MODIFIED_FILES
          
          # Commit the changes with a reference to the issue
          git commit -m "Fix #$ISSUE_NUMBER: $ISSUE_TITLE" || {
            echo "Nothing to commit, exiting"
            exit 1
          }
          
          # For debugging: show what was committed
          git show --name-status --oneline HEAD
          
          # Output the branch name for later steps
          echo "branch=fix/issue-$ISSUE_NUMBER-retry-$TIMESTAMP" >> $GITHUB_OUTPUT

      - name: Push branch
        run: |
          git push origin "${{ steps.solution.outputs.branch }}"

      - name: Create Pull Request
        if: success()
        id: create_pr
        env:
          GH_TOKEN: ${{ secrets.PAT_GITHUB }}
        run: |
          ISSUE_NUMBER="${{ steps.issue_info.outputs.issue_number }}"
          BRANCH_NAME="${{ steps.solution.outputs.branch }}"
          ISSUE_TITLE="${{ steps.issue_info.outputs.issue_title }}"
          
          # Configure git for the GitHub Actions bot
          git config --global user.name "GitHub Actions Bot"
          git config --global user.email "actions@github.com"
          
          # Ensure temp directory exists
          mkdir -p ./.temp
          
          # Create a simple PR description file
          echo "This PR addresses issue #$ISSUE_NUMBER." > ./.temp/pr_body.txt
          echo "" >> ./.temp/pr_body.txt
          echo "## Changes" >> ./.temp/pr_body.txt
          echo "- Modified code to fix the issue as described" >> ./.temp/pr_body.txt
          echo "- Implemented changes based on AI analysis" >> ./.temp/pr_body.txt
          echo "" >> ./.temp/pr_body.txt
          echo "## Validation" >> ./.temp/pr_body.txt
          echo "- The changes have been automatically generated and tested" >> ./.temp/pr_body.txt
          echo "- Please review and provide feedback" >> ./.temp/pr_body.txt
          echo "" >> ./.temp/pr_body.txt
          echo "Closes #$ISSUE_NUMBER" >> ./.temp/pr_body.txt
          
          # Create PR using the body from the file
          PR_URL=$(gh pr create --base main --head "$BRANCH_NAME" \
            --title "Fix #$ISSUE_NUMBER: $ISSUE_TITLE" \
            --body-file ./.temp/pr_body.txt || echo "")
          
          if [ -z "$PR_URL" ]; then
            echo "Failed to create PR"
            exit 1
          fi
          
          echo "PR created: $PR_URL"
          
          # Extract PR number from URL
          PR_NUMBER=$(echo $PR_URL | grep -oE '[0-9]+$')
          
          # Output the PR number for later steps
          echo "pr_number=$PR_NUMBER" >> $GITHUB_OUTPUT
          echo "pr_url=$PR_URL" >> $GITHUB_OUTPUT
          
      - name: Cleanup temporary files
        if: always()
        run: |
          # Remove temp directory and files
          rm -rf ./.temp
          # List any remaining temp files at root
          find . -maxdepth 1 -name "*_*.txt" -delete
          find . -maxdepth 1 -name "*.md" -not -name "README.md" -delete
          # Ensure .aider files are removed
          rm -f ./.aider.chat.history.md
          rm -f ./.aider.input.md
          rm -f ./.aider.output.md
          echo "Temporary files cleaned up" 
